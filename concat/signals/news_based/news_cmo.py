"""
OVERVIEW:
First identifies important events, i.e days where:
(1) relevant news was published
(2) alpha on that day exceeds expected alpha by 2 standard deviations

    Remarks:
    alpha moments are calculated based on previous 6 months of data

Next, for each of these days, checks:
(3) alpha on that day
(4) cumulative alpha over 3 days (that day + 2 next days)
(5) if over the period starting 5 days before that day, and ending 2 days
    after that day, a buy/sell signal - generated by CMO strategy -
    occurred

    alpha > 0 AND cum_alpha > 0 AND cmo_buy_signal => buy signal
    alpha < 0 AND cum_alpha < 0 AND cmo_sell_signal => sell signal

"""
import datetime as dt
import pandas as pd

from blvresearch.concat.signals.news_based.news_common_funcs import (
    get_days_to_check
)
from blvresearch.concat.signals.price_based.cmo_signals import (
    _calculate_cmo_values, _adjust_series_of_signals
)


DESCRIPTION_BUY = """
This is a BUY signal generated using company news and its stock return.
Two days before the signal day relevant news about this company was published
and its stock experienced an abnormal positive alpha.
In addition the following has occurred:
* cumulative alpha over the 3 days (including this day) was also positive
* in the previous 8 days a buy signal generated by Chande Momentum Oscillator
  also occurred
"""


DESCRIPTION_SELL = """
This is a SELL signal generated using company news and its stock return.
Two days before the signal day relevant news about this company was published
and its stock experienced an abnoraml negative alpha.
In addition the following has occurred:
* cumulative alpha over the 3 days (including this day) was also negative
* in the previous 8 days a sell signal generated by Chande Momentum Oscillator
  also occurred.
"""


DESCRIPTION_COMMON = """
The Chande Momentum Oscillator was created by Tushar Chande.
To get its value we calculate the difference between all positive and all
negative returns over the last 9 days and divide it by the total return over
this period.
This value is then multiplied by 100 to get an indicator ranging from
-100 to +100.

For all trading strategies, tha past performance does
not guarantee future results.
"""


DAYS_AFTER = 2
FIRST_LOC = (8 +  # CMO takes 9 days to generate a signal hence first 9 days
             5)   # cannot give a signal, then we also look back 5 days to find
                  # out if a CMO strategy generated a signal
LAST_LOC = -DAYS_AFTER


def get_news_cmo_signals(days_to_check, data, first_loc, last_loc):
    first_day = data.index[first_loc + FIRST_LOC]
    last_day = data.index[last_loc + LAST_LOC]

    cmo_signals = _get_cmo_signals(data, periods=9)
    cmo_signals = cmo_signals.reindex(data.index)

    result = pd.Series(index=data.index)
    for date in days_to_check[first_day:last_day].index:
        loc = data.index.get_loc(date)
        signal_day = data.index[loc + DAYS_AFTER]
        if ((cmo_signals[loc - 5:loc + 1 + DAYS_AFTER] == False).any() and
            _is_negative_surprise(data, date)):
            result[signal_day] = False
        elif ((cmo_signals[loc - 5:loc + 1 + DAYS_AFTER] == True).any() and
              _is_positive_surprise(data, date)):
            result[signal_day] = True
    return result.dropna()


def _is_negative_surprise(data, date):
    loc = data.index.get_loc(date)
    if (data['alpha'][date] < 0 and
        data['alpha'][loc:loc + 1 + DAYS_AFTER].sum() < 0):
        return True
    return False


def _is_positive_surprise(data, date):
    loc = data.index.get_loc(date)
    if (data['alpha'][date] > 0 and
        data['alpha'][loc:loc + 1 + DAYS_AFTER].sum() > 0):
        return True
    return False


def _get_cmo_signals(data, periods):
    def _cmo_logic(x):
        if x <= -0.3:
            return True
        elif x >= 0.3:
            return False
    cmos = _calculate_cmo_values(data['alpha'], periods)
    result = cmos.dropna().map(_cmo_logic)
    result = _adjust_series_of_signals(result)
    return result


def get_news_cmo_descr(signal):
    if signal == True:
        result = DESCRIPTION_BUY
    elif signal == False:
        result = DESCRIPTION_SELL
    result += DESCRIPTION_COMMON
    return result
