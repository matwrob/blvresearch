"""
OVERVIEW:
Simple strategy based on news.

First identifies important events by considering alpha and existence of
relevant news on a given day.
Alpha needs to exceed mean by 1 sigma in absolute terms.

Next for each of these days, it checks:
(1) what was the return on that day
(2) what was the return over the next 3 days
(3) how many down days in comparison to how many up days occurred over the next
    3 days
(4) if over the previous 5 or the next 3 days a buy/sell signal - generated by
    MODIFIED-CMO strategy - occurred

"""
import datetime as dt
import pandas as pd

from blvresearch.concat.signals.utils import remove_consecutive_values
from blvresearch.concat.signals.news_based.news_common_funcs import (
    get_days_to_check
)
from blvresearch.concat.signals.price_based.cmo_signals import (
    _calculate_cmo_values, _adjust_series_of_signals
)


FIRST_LOC = (8 +  # CMO takes 9 days to generate a signal
             5)   # number of days we look back for CMO signals
LAST_LOC = -3


def get_signals(data):
    days_to_check = get_days_to_check(data, FIRST_LOC, LAST_LOC)
    cmo_signals = get_cmo_signals(data, periods=9)
    result = pd.Series(index=data.index)
    for date in days_to_check.index:
        loc = data.index.get_loc(date)
        signal_day = data.index[loc + 3]
        if (_is_negative_suprise(data, date) and
            (cmo_signals[loc - 5:loc + 3] == False).any()):
            result[signal_day] = False
        elif (_is_positive_suprise(data, date) and
              (cmo_signals[loc - 5:loc + 3] == True).any()):
            result[signal_day] = True
    return remove_consecutive_values(result)


def _is_negative_suprise(df, date):
    loc = df.index.get_loc(date)
    if (df['alpha'][date] < 0 and
        df['alpha'][loc:loc + 3].sum() < 0 and
        df['alpha'][loc:loc + 3].map(func).sum() < 0):
        return True
    return False


def _is_positive_suprise(df, date):
    loc = df.index.get_loc(date)
    if (df['alpha'][date] > 0 and
        df['alpha'][loc:loc + 3].sum() > 0 and
        df['alpha'][loc:loc + 3].map(func).sum() > 0):
        return True
    return False


def func(x):
    if x < 0:
        return -1
    else:
        return 1


def get_cmo_signals(data, periods):
    returns = data['alpha']
    cmos = _calculate_cmo_values(returns, periods)
    result = cmos.dropna().map(_cmo_logic)
    result = _adjust_series_of_signals(result)
    return result


def _cmo_logic(x):
    if x <= -0.3:
        return True
    elif x >= 0.3:
        return False
