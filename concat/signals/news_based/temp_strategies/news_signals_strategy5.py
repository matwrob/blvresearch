"""
OVERVIEW:
First identifies important events, i.e.
(1) relevant news need to exist
(2) alpha needs to exceed expected alpha by 1 standard deviation

    Remark: alpha moments are calculated based on previous 6 months

Next for each of these days, it checks:
(1) what was the return on that day
(2) what was the return over the next 3 days
(3) if over the previous 5 or the next 3 days a buy/sell signal - generated by
    MA strategy - occurred

"""
import datetime as dt
import pandas as pd

from blvresearch.concat.signals.utils import remove_consecutive_values
from blvresearch.concat.signals.news_based.news_common_funcs import (
    get_days_to_check
)
from blvresearch.concat.signals.price_based.moving_average import (
    adjust_series_of_signals
)


DESCRIPTION_BUY = """
This is a BUY signal generated using company news and its stock return.\n
Two days before the signal day relevant news about this company was published
and its stock experienced an abnormal positive alpha.
In addition the following has occurred:
* cumulative alpha over previous 3 days (including this day) was also positive
* in the previous 8 days a buy signal generated by Chande Momentum Oscillator
  also occurred
"""


DESCRIPTION_SELL = """
This is a SELL signal generated using company news and its stock return.\n
Two days before the signal day relevant news about this company was published
and its stock experienced an abnoraml negative alpha.
In addition the following has occurred:
* cumulative alpha over previous 3 days (including this day) was also negative
* in the previous 8 days a sell signal generated by Chande Momentum Oscillator
  also occurred.
"""


DESCRIPTION_COMMON = """
This Moving Average strategy uses exponential weighting and not equal
weighting which is used in simple moving averages.
Exponential moving averages give more weight to more recent days
and therefore better adapts to changes of the price.

For all trading strategies, tha past performance does not guarantee
future results.
"""

DAYS_AFTER = 2
FIRST_LOC = (20 +  # MA window
             3 +   # MA confirmation window
             5)    # days to look back for MA signal
LAST_LOC = -DAYS_AFTER


def get_news_movavg_signals(days_to_check, data, first_loc, last_loc):
    first_day = data.index[first_loc + FIRST_LOC]
    last_day = data.index[last_loc + LAST_LOC]

    ma_signals = _get_movavg_signals(data, window=20, confirmation_window=3)
    ma_signals = ma_signals.reindex(data.index)

    result = pd.Series(index=data.index)
    for date in days_to_check[first_day:last_day].index:
        loc = data.index.get_loc(date)
        signal_day = data.index[loc + DAYS_AFTER]
        if ((ma_signals[loc - 5:loc + 1 + DAYS_AFTER] == False).any() and
            _is_negative_surprise(data, date)):
            result[signal_day] = False
        elif ((ma_signals[loc - 5:loc + 1 + DAYS_AFTER] == True).any() and
              _is_positive_surprise(data, date)):
            result[signal_day] = True
    return remove_consecutive_values(result)


def _is_negative_surprise(data, date):
    loc = data['alpha'].index.get_loc(date)
    if (data['alpha'][date] < 0 and
        data['alpha'][loc:loc + 1 + DAYS_AFTER].sum() < 0):
        return True
    return False


def _is_positive_suprise(data, date):
    loc = data.index.get_loc(date)
    if (data['alpha'][date] > 0 and
        data['alpha'][loc:loc + 1 + DAYS_AFTER].sum() > 0):
        return True
    return False


def _get_movavg_signals(data, window, confirmation_window):
    prices = to_prices(data['abs_ret'], set_first_to_na=True)
    avg = pd.ewma(prices, span=window)
    result = returns > avg
    result = adjust_series_of_signals(result, confirmation_window)
    return result
